#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main(void) {
    int n;
    // Ввод N с проверкой
    if (scanf("%d", &n) != 1) {
        fprintf(stderr, "Invalid input: expected integer N\n");
        return 1; // ошибка ввода
    }
    if (n <= 0) {
        printf("NO\n");
        return 0;
    }

    long long *a = malloc(sizeof(long long) * n);
    if (!a) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    // Чтение ровно N элементов с проверкой "меньше / неверный формат"
    for (int i = 0; i < n; ++i) {
        if (scanf("%lld", &a[i]) != 1) {
            fprintf(stderr, "Invalid input: expected %d integers for array (too few or wrong format)\n", n);
            free(a);
            return 1;
        }
    }

    // Проверка отсутствия лишних токенов (если есть хоть один дополнительный токен -> ошибка)
    char extra[256];
    int r = scanf("%255s", extra);
    if (r == 1) {
        fprintf(stderr, "Invalid input: expected exactly %d integers, but more were provided\n", n);
        free(a);
        return 1;
    }
    // если r == EOF — вход закончился ровно после n чисел, всё ок

    // Построим suffix_max: максимум справа от i (для i = n-1 — считаем "нет справа")
    long long *suffix_max = malloc(sizeof(long long) * n);
    if (!suffix_max) {
        fprintf(stderr, "Memory allocation failed\n");
        free(a);
        return 1;
    }
    suffix_max[n-1] = LLONG_MIN;
    for (int i = n - 2; i >= 0; --i) {
        long long candidate = a[i+1];
        long long next = suffix_max[i+1];
        suffix_max[i] = (candidate > next) ? candidate : next;
    }

    // Проход слева направо: prefix_min = min на левой части
    long long prefix_min = LLONG_MAX;
    for (int i = 0; i < n; ++i) {
        int cond_left  = (i == 0) ? 1 : (a[i] < prefix_min);       // меньше всех слева (или слева нет)
        int cond_right = (i == n-1) ? 1 : (a[i] > suffix_max[i]); // больше всех справа (или справа нет)
        if (cond_left && cond_right) {
            printf("YES\n%d\n", i + 1); // индекс 1-based
            free(a);
            free(suffix_max);
            return 0;
        }
        if (a[i] < prefix_min) prefix_min = a[i];
    }

    printf("NO\n");
    free(a);
    free(suffix_max);
    retu
rn 0;
}
